'use strict';

var utils = require('../utils.js');

// ---------- utils
function createReadableStream() {
    let controller = null;
    const stream = new ReadableStream({
        start (c) {
            controller = c;
        }
    });
    return [
        stream,
        controller
    ];
}
// ---------- types
const CHUNK_VALUE_TYPE_PROMISE = 0;
const CHUNK_VALUE_TYPE_ASYNC_ITERABLE = 1;
const PROMISE_STATUS_FULFILLED = 0;
const PROMISE_STATUS_REJECTED = 1;
const ASYNC_ITERABLE_STATUS_DONE = 0;
const ASYNC_ITERABLE_STATUS_VALUE = 1;
const ASYNC_ITERABLE_STATUS_ERROR = 2;
function isPromise(value) {
    return (utils.isObject(value) || utils.isFunction(value)) && typeof value?.['then'] === 'function' && typeof value?.['catch'] === 'function';
}
class MaxDepthError extends Error {
    constructor(path){
        super('Max depth reached at path: ' + path.join('.'));
        this.path = path;
    }
}
function createBatchStreamProducer(opts) {
    const { data  } = opts;
    let counter = 0;
    const placeholder = 0;
    const [stream, controller] = createReadableStream();
    const pending = new Set();
    function maybeClose() {
        if (pending.size === 0) {
            controller.close();
        }
    }
    function hydratePromise(promise, path) {
        //
        const error = checkMaxDepth(path);
        if (error) {
            promise.catch(()=>{
            // ignore
            });
            promise = Promise.reject(error);
        }
        const idx = counter++;
        pending.add(idx);
        const enqueue = (value)=>{
            controller.enqueue(value);
        };
        promise.then((it)=>{
            enqueue([
                idx,
                PROMISE_STATUS_FULFILLED,
                hydrate(it, path)
            ]);
        }).catch((error)=>{
            opts.onError?.({
                error,
                path
            });
            enqueue([
                idx,
                PROMISE_STATUS_REJECTED,
                opts.formatError?.({
                    error,
                    path
                })
            ]);
        }).finally(()=>{
            pending.delete(idx);
            maybeClose();
        });
        return idx;
    }
    function hydrateAsyncIterable(iterable, path) {
        const error = checkMaxDepth(path);
        if (error) {
            iterable = {
                [Symbol.asyncIterator] () {
                    throw error;
                }
            };
        }
        const idx = counter++;
        pending.add(idx);
        void (async ()=>{
            try {
                for await (const item of iterable){
                    controller.enqueue([
                        idx,
                        ASYNC_ITERABLE_STATUS_VALUE,
                        hydrate(item, path)
                    ]);
                }
                controller.enqueue([
                    idx,
                    ASYNC_ITERABLE_STATUS_DONE
                ]);
            } catch (error) {
                opts.onError?.({
                    error,
                    path
                });
                controller.enqueue([
                    idx,
                    ASYNC_ITERABLE_STATUS_ERROR,
                    opts.formatError?.({
                        error,
                        path
                    })
                ]);
            } finally{
                pending.delete(idx);
                maybeClose();
            }
        })();
        return idx;
    }
    function checkMaxDepth(path) {
        if (opts.maxDepth && path.length > opts.maxDepth) {
            return new MaxDepthError(path);
        }
        return null;
    }
    function hydrateChunk(value, path) {
        if (isPromise(value)) {
            return [
                CHUNK_VALUE_TYPE_PROMISE,
                hydratePromise(value, path)
            ];
        }
        if (utils.isAsyncIterable(value)) {
            if (opts.maxDepth && path.length >= opts.maxDepth) {
                throw new Error('Max depth reached');
            }
            return [
                CHUNK_VALUE_TYPE_ASYNC_ITERABLE,
                hydrateAsyncIterable(value, path)
            ];
        }
        return null;
    }
    function hydrate(value, path) {
        const reg = hydrateChunk(value, path);
        if (reg) {
            return [
                [
                    placeholder
                ],
                [
                    null,
                    ...reg
                ]
            ];
        }
        if (!utils.isObject(value)) {
            return [
                [
                    value
                ]
            ];
        }
        const newObj = {};
        const asyncValues = [];
        for (const [key, item] of Object.entries(value)){
            const transformed = hydrateChunk(item, [
                ...path,
                key
            ]);
            if (!transformed) {
                newObj[key] = item;
                continue;
            }
            newObj[key] = placeholder;
            asyncValues.push([
                key,
                ...transformed
            ]);
        }
        return [
            [
                newObj
            ],
            ...asyncValues
        ];
    }
    const newHead = {};
    for (const [key, item] of Object.entries(data)){
        newHead[key] = hydrate(item, [
            key
        ]);
    }
    return [
        newHead,
        stream
    ];
}
/**
 * JSON Lines stream producer
 * @see https://jsonlines.org/
 */ function jsonlStreamProducer(opts) {
    let [head, stream] = createBatchStreamProducer(opts);
    const { serialize  } = opts;
    if (serialize) {
        head = serialize(head);
        stream = stream.pipeThrough(new TransformStream({
            transform (chunk, controller) {
                controller.enqueue(serialize(chunk));
            }
        }));
    }
    return stream.pipeThrough(new TransformStream({
        start (controller) {
            controller.enqueue(JSON.stringify(head) + '\n');
        },
        transform (chunk, controller) {
            controller.enqueue(JSON.stringify(chunk) + '\n');
        }
    })).pipeThrough(new TextEncoderStream());
}
class StreamInterruptedError extends Error {
    constructor(cause){
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore https://github.com/tc39/proposal-error-cause
        super('Invalid response or stream interrupted', {
            cause
        });
    }
}
class AsyncError extends Error {
    constructor(data){
        super('Received error from server');
        this.data = data;
    }
}
const nodeJsStreamToReaderEsque = (source)=>{
    return {
        getReader () {
            const [stream, controller] = createReadableStream();
            source.on('data', (chunk)=>{
                controller.enqueue(chunk);
            });
            source.on('end', ()=>{
                controller.close();
            });
            source.on('error', (error)=>{
                controller.error(error);
            });
            return stream.getReader();
        }
    };
};
function createLineAccumulator(from) {
    const reader = 'getReader' in from ? from.getReader() : nodeJsStreamToReaderEsque(from).getReader();
    let lineAggregate = '';
    return new ReadableStream({
        async pull (controller) {
            const { done , value  } = await reader.read();
            if (done) {
                controller.close();
            } else {
                controller.enqueue(value);
            }
        },
        cancel () {
            return reader.cancel();
        }
    }).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({
        transform (chunk, controller) {
            lineAggregate += chunk;
            const parts = lineAggregate.split('\n');
            lineAggregate = parts.pop() ?? '';
            for (const part of parts){
                controller.enqueue(part);
            }
        }
    }));
}
function createConsumerStream(from) {
    const stream = createLineAccumulator(from);
    let sentHead = false;
    return stream.pipeThrough(new TransformStream({
        transform (line, controller) {
            if (!sentHead) {
                const head = JSON.parse(line);
                controller.enqueue(head);
                sentHead = true;
            } else {
                const chunk = JSON.parse(line);
                controller.enqueue(chunk);
            }
        }
    }));
}
function createDeferred() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    return {
        promise,
        resolve: resolve,
        reject: reject
    };
}
/**
 * JSON Lines stream consumer
 * @see https://jsonlines.org/
 */ async function jsonlStreamConsumer(opts) {
    const { deserialize =(v)=>v  } = opts;
    let source = createConsumerStream(opts.from);
    if (deserialize) {
        source = source.pipeThrough(new TransformStream({
            transform (chunk, controller) {
                controller.enqueue(deserialize(chunk));
            }
        }));
    }
    let headDeferred = createDeferred();
    const chunkDeferred = new Map();
    const controllers = new Map();
    function dehydrateChunkDefinition(value) {
        const [_path, type, chunkId] = value;
        const [stream, controller] = createReadableStream();
        controllers.set(chunkId, controller);
        // resolve chunk deferred if it exists
        const deferred = chunkDeferred.get(chunkId);
        if (deferred) {
            deferred.resolve(controller);
            chunkDeferred.delete(chunkId);
        }
        switch(type){
            case CHUNK_VALUE_TYPE_PROMISE:
                {
                    return new Promise((resolve, reject)=>{
                        // listen for next value in the stream
                        const reader = stream.getReader();
                        reader.read().then((it)=>{
                            if (it.done) {
                                reject(new Error('Promise chunk ended without value'));
                                return;
                            }
                            if (it.value instanceof StreamInterruptedError) {
                                reject(it.value);
                                return;
                            }
                            const value = it.value;
                            const [_chunkId, status, data] = value;
                            switch(status){
                                case PROMISE_STATUS_FULFILLED:
                                    resolve(dehydrate(data));
                                    break;
                                case PROMISE_STATUS_REJECTED:
                                    reject(opts.formatError?.({
                                        error: data
                                    }) ?? new AsyncError(data));
                                    break;
                            }
                        }).catch(reject).finally(()=>{
                            // reader.releaseLock();
                            controllers.delete(chunkId);
                        });
                    });
                }
            case CHUNK_VALUE_TYPE_ASYNC_ITERABLE:
                {
                    return {
                        [Symbol.asyncIterator]: async function*() {
                            const reader = stream.getReader();
                            while(true){
                                const { done , value  } = await reader.read();
                                if (done) {
                                    break;
                                }
                                if (value instanceof StreamInterruptedError) {
                                    throw value;
                                }
                                const [_chunkId, status, data] = value;
                                switch(status){
                                    case ASYNC_ITERABLE_STATUS_VALUE:
                                        yield dehydrate(data);
                                        break;
                                    case ASYNC_ITERABLE_STATUS_DONE:
                                        controllers.delete(chunkId);
                                        return;
                                    case ASYNC_ITERABLE_STATUS_ERROR:
                                        controllers.delete(chunkId);
                                        throw opts.formatError?.({
                                            error: data
                                        }) ?? new AsyncError(data);
                                }
                            }
                        }
                    };
                }
        }
    }
    function dehydrate(value) {
        const [[data], ...asyncProps] = value;
        for (const value1 of asyncProps){
            const dehydrated = dehydrateChunkDefinition(value1);
            const [path] = value1;
            if (path === null) {
                return dehydrated;
            }
            data[path] = dehydrated;
        }
        return data;
    }
    const closeOrAbort = (reason)=>{
        const error = new StreamInterruptedError(reason);
        headDeferred?.reject(error);
        for (const deferred of chunkDeferred.values()){
            deferred.reject(error);
        }
        chunkDeferred.clear();
        for (const controller of controllers.values()){
            controller.enqueue(error);
            controller.close();
        }
        controllers.clear();
    };
    source.pipeTo(new WritableStream({
        async write (chunkOrHead) {
            if (headDeferred) {
                const head = chunkOrHead;
                for (const [key, value] of Object.entries(chunkOrHead)){
                    const parsed = dehydrate(value);
                    head[key] = parsed;
                }
                headDeferred.resolve(head);
                headDeferred = null;
                return;
            }
            const chunk = chunkOrHead;
            const [idx] = chunk;
            let controller = controllers.get(idx);
            if (!controller) {
                let deferred = chunkDeferred.get(idx);
                if (!deferred) {
                    deferred = createDeferred();
                    chunkDeferred.set(idx, deferred);
                }
                controller = await deferred.promise;
            }
            controller.enqueue(chunk);
        },
        close: closeOrAbort,
        abort: closeOrAbort
    })).catch((error)=>{
        opts.onError?.({
            error
        });
        closeOrAbort(error);
    });
    return [
        await headDeferred.promise,
        {
            controllers
        }
    ];
}

exports.isPromise = isPromise;
exports.jsonlStreamConsumer = jsonlStreamConsumer;
exports.jsonlStreamProducer = jsonlStreamProducer;
